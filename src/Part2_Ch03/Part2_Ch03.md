<h3>01. 객체 간의 상속은 어떤 의미일까?</h3>

* 상속

  * 이미 구현된 클래스보다 더 구체적은 기능을 가진 클래스 구현 시 기존 클래스 상속

  * 용어 : 상위 클래스(A), 하위 클래스(B), A 클래스가 B 클래스에게 상속함, B 클래스가 A 클래스를 상속받음

  * extends 키워드 뒤에는 <u>하나의 클래스만</u> 올 수 있음 (단일 상속)

<br>

* 상속의 문법

```
class B extends A { }
```

<br>

<h3>02. 상속을 활용한 멤버십 클래스 구현하기</h3>

* protected 접근 제어자

  * 상위 클래스에 선언된 private 멤버 변수는 하위 클래스에서 접근 할 수 없음

  * 외부 클래스는 접근 불가능, 하위 클래스는 접근 가능 -> protected 접근 제어자

<br>

<h3>03. 상속에서 클래스 생성 과정과 형 변환</h3>

* 하위 클래스 생성 과정

  * 하위 클래스를 생성하면 상위 클래스가 먼저 생성 됨
  
  * 클래스가 상속 받은 경우 하위 클래스 생성자는 반드시 상위 클래스 생성자 호출

<br>

* super 키워드

  * 하위 클래스에서 가지는 상위 클래스에 대한 참조 값
  
  * super() 는 상위 클래스의 기본 생성자 호출

  * super는 상위 클래스 인스턴스의 참조 값 가짐 -> 상위 클래스의 메서드나 멤버 변수에 접근 가능

<br>

* 상속에서 인스턴스 메모리 상태 : 항상 상위 클래스 인스턴스 생성 후 하위 인스턴스 생성 (<u>힙 메모리에</u>)

<br>

* <u>형 변환(업캐스팅)</u>

  * 상위 클래스로 변수 선언, 하위 클래스의 생성자로 인스턴스 생성

  ```
  Customer lee = new VIPCustomer();
  ```
  
  * 상위 클래스 타입의 변수에 하위 클래스 변수 대입

  ```
  VIPCustomer vCustomer = new VIPCustomer();
  addCustomer(vCustomer);
  int addCustomer(Customer customer) { }
  ```
  
  * 하위 클래스는 상의 클래스 타입 내포함 -> 상위 클래스로 묵시적 형 변환 가능

  * 상속 관계에서 모든 하위 클래스는 상위 클래스로 형 변환(업캐스팅) 가능 (역은 성립 X)

<br>

* 형 변환과 메모리

  * VIPCustomer() 생성자 -> VIPCustomer 클래스의 모든 멤버 변수에 대한 메모리 생성

  * <u>변수 타입이 Customer -> 실제 접근 가능한 변수나 메서드는 Customer의 변수와 메서드</u>

```
Customer vc = new VIPCustomer();
```

<br>

<h3>04. 메서드 재정의하기(overriding)</h3>

* 하위 클래스에서 메서드 재정의 하기

  * 오버라이딩(overriding) : 상위 클래스에 정의된 메서드 구현 내용과 하위 클래스에서 구현할 내용이 맞지 않으면 하위 클래스에서 동일한 이름의 메서드 재정의 가능

<br>

* @Overrding 애노테이션(annotation)

  * 주석의 의미를 가짐

  * 컴파일러에게 특별한 정보 제공 (@Overrdie : 재정의된 메서드라는 정보 제공)

<br>

* 형 변환과 오버라이딩 메서드 호출

  * <u>자바에서는 항상 인스턴스의 메서드가 호출</u>

  * <u>자바의 모든 메서드는 가상 메서드(virtual method)</u>

<br>

<h3>05. 메서드 재정의와 가상 메서드 원리</h3>

* 메서드는 어떻게 호출되고 실행 되는가?

  * 메서드 이름은 주소값 나타냄

  * 메서드는 명령어의 집합이고 프로그램 로드 시 메서드 영역(코드 영역)에 명령어 집합이 위치

  * 해당 메서드 호출 시 명령어 집합이 있는 주소를 찾아 명령어 실행됨

  * <u>메서드에서 사용하는 변수들은 스택 메모리에 위치함</u>

  * 다른 인스턴스라도 같은 메서드 코드는 같은 메서드 호출됨

  * <u>인스턴스 생성 시 변수는 힙 메모리에 따로 생성됨</u>
  
  * <u>메서드 명령어 집합은 처음 한 번만 로드</u>

<br>

* 가상 메서드 원리

  * 가상 메서드 테이블(virtual method table)에서 해당 메서드에 대한 주소 가지고 있음

  * 재정의 된 경우, 재정의 된 메서드 주소 가리킴

<br>

<h3>06. 다형성과 다형성을 사용하는 이유</h3>

* 다형성을 사용하는 이유?

  * 상위 클래스에서는 공통적인 부분 제공

  * 하위 클래스에서는 각 클래스에 맞는 기능 구현

  * 여러 클래스를 상위 클래스로 핸들링 할 수 있음

<br>

<h3>07. 상속은 언제 사용할까?</h3>

* IS-A 관계 (is a relationship : inheritance)

  * 일반적인 & 구체적인 개념 관계

  * 상속

<br> 

* HAS-A 관계 (composition)

  * 클래스가 다른 클래스를 포함하는 관계 (ex. Student, Subject / Library, ArrayList)

  * 상속하지 않음

<br>

<h3>08.다운 캐스팅과 instanceof</h3>

* 다운 캐스팅(downcasting)

  * 업캐스팅된 클래스를 다시 원래의 타입으로 형 변환(명시적)

  ```
  Customer vc = new VIPCustomer();              // 업캐스팅
  VIPCustomer vCustomer = (VIPCustomer)vc;      // 다운캐스팅
  ```

<br>

* instanceof를 이용하여 인스턴스의 형 체크 : 원래 인스턴스의 형이 맞는지 여부를 체크하는 키워드가 맞으면 true, 아니면 false 반환

<br>

<h3>09. 추상 클래스(abstract class) 구현하기</h3>

* 추상 클래스란?

  * 구현 코드 없이 메서드 선언만 있는 추상 메서드(abstract method)를 포함한 클래스

  * 메서드 선언(declaration) : 반환타입, 메서드 이름, 매개변수

  * 메서드 정의(definition) : 메서드 구현과 동일한 의미, 구현부 가짐

  * abstract 예약어 사용

  * new (인스턴스화) 불가능

  ```
  int add(int x, int y) //     선언
  int add(int x, int y) {} //  구현부 존재, 추상 메서드 아님
  ```
  
<br>
  
* 추상 클래스 구현

  * abstract로 선언된 메서드 가진 클래스는 abstract로 선언

  * 모든 메서드가 구현된 클래스여도 abstract로 선언되면 추상 클래스로 인스턴스화 불가능
  
  * 추상 클래스의 추상 메서드는 하위 클래스가 상속하여 구현

<br>

<h3>10. 추상 클래스 응용 - 템플릿 메서드 패턴</h3>

* 템플릿 메서드

  * 코드의 흐름(시나리오) 정의하는 메서드

  * final로 선언하여 하위 클래스에서 재정의 불가능 하게 함

  * 프레임워크에서 많이 사용되는 설계 패턴

  * 상위 클래스에서 메서드 및 추상 메서드 선언하고 final 키워드 이용해 run() 함수 구현

  * 하위 클래스에서 추상 메서드 구현

<br>

* final 예약어
  
  * final 메서드 : 하위 클래스에서 재정의 불가능한 베서드

  * final 클래스 : 상속할 수 없는 클래스

  * final 변수 : 값이 변경될 수 없는 상수

  ```
  public static final double PI = 3.14;
  ```

<br>

<h3>11. 인터페이스(interface)</h3>

* 인터페이스란?

  * 모든 메서드가 추상 메서드로 선언 (ex. public abstract)
  
  * 모든 변수는 상수로 선언됨 (ex. public static final)

  * 자바8 부터 디폴트 메서드(default method)와 정적 메서드(static method) 기능의 제공으로 일부 구현 코드 존재

<br>

* 인터페이스 구현과 형 변환

  * 인터페이스를 구현한 클래스는 인터페이스 형으로 선언한 변수로 형 변환 가능

  * 상속에서의 형 변환과 동일한 의미

  * 구현 코드가 없으므로 여러 인터페이스 구현 가능

  * 형 변환되는 경우 인터페이스에 선언된 메서드만을 사용 가능

<br>

<h3>12. 인터페이스는 왜 쓰는가?</h3>

* 인터페이스가 하는 일

  * 클래스나 프로그램이 제공하는 기능 명시적으로 선언

  * 클라이언트 프로그램은 인터페이스에 선언된 메서드 명세만 보고 이를 구현한 클래스 사용 가능

  * 어떤 객체가 하나의 인터페이스 타입이라는 것은 그 인터페이스가 제공하는 모든 메서드 구현함을 의미

  * 인터페이스를 구현한 다양한 객체 사용 - 다형성

  * ex. JDBC 인터페이스

<br>

<h3>13. 인터페이스를 활용한 다형성 구현 (dao - data access object 구현)</h3>

* db.properties는 프로젝트 파일에서 만들어야 함

<br>

<h3><u>14. 인터페이스의 여러가지 요소</u></h3>

* 상수

  * 모든 변수는 상수로 변환

  ```
  double PI = 3.14;
  int ERROR = -9999;
  ```
  
<br>

* 추상 메서드

  * 모든 선언된 메서드는 추상 메서드 public abstract

<br>

* 디폴트 메서드 (자바 8이후)

  * 구현을 가지는 메서드

  * 인터페이스 구현 클래스에서 공통으로 사용 가능한 기본 메서드

  * 인터페이스 구현한 클래스의 인스턴스가 생성 되어야 사용 가능

  * default 키워드 사용, 구현하는 클래스에서 재정의 가능

  ```
  default void description() { }
  
  @Override
  public void description() { }
  ```
  
<br>

* 정적 메서드

  * 인스턴스 생성과 상관 없이 인터페이스 타입으로 사용 가능 메서드

  ```
  static int total(int [] arr) { ... }
  ```

<br>

* private 메서드 (자바 9 이후)

  * 인터페이스를 구현한 클래스에서 사용하거나 재정의 불가능

  * 인터페이스 내부에서만 사용하기 위해 구현하는 메서드

  * default 메서드나 static 메서드에서 사용 가능

  ```
  private void myMethod() { ... }
  private static void mystaticMethod() { ... }
  ```
  
<br>

<h3>15. 여러 인터페이스 구현하기, 인터페이스의 상속</h3>

* 여러 인터페이스 구현

  * 자바의 인터페이스는 구현 코드가 없음 -> 하나의 클래스가 여러 인터페이스 구현 가능

  * 디폴트 메서드가 중복 되는 경우, 구현하는 클래스에서 재정의

  * 여러 인터페이스를 구현한 클래스는 인터페이스 타입으로 형 변환되는 경우, 인터페이스에 선언된 메서드만 사용 가능

<br>

* 디폴트 메서드가 중복 되는 경우

  * 두 개의 인터페이스를 구현하는 클래스에서 반드시 해당 메서드를 재정의 해야 함

<br>

* 인터페이스의 상속

  * 인터페이스 사이에도 상속 가능

  * extends 키워드 사용
  
  * 다중 상속 가능, 구현 코드의 상속 불가능 -> 타입 상속이라고 함